/*
  SPDX-FileCopyrightText: Â© 2025 Stefano Chizzolini and contributors

  SPDX-License-Identifier: LGPL-3.0-only

  This file (Asserter.java) is part of pdfclown-common-build module in pdfClown Common project
  <https://github.com/pdfclown/pdfclown-common>

  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. If you reuse (entirely or partially)
  this file, you MUST add your own copyright notice in a separate comment block above this file
  header, listing the main changes you applied to the original source.
 */
package org.pdfclown.common.build.test.assertion;

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
import static java.util.Objects.requireNonNull;
import static java.util.Objects.requireNonNullElse;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.pdfclown.common.build.internal.util_.Chars.LF;
import static org.pdfclown.common.build.internal.util_.Exceptions.failedIO;
import static org.pdfclown.common.build.internal.util_.Exceptions.runtime;
import static org.pdfclown.common.build.internal.util_.Objects.textLiteral;
import static org.pdfclown.common.build.internal.util_.Strings.EMPTY;
import static org.pdfclown.common.build.internal.util_.Strings.abbreviateMultiline;
import static org.pdfclown.common.build.internal.util_.io.Files.copyDirectory;
import static org.pdfclown.common.build.internal.util_.io.Files.resetDirectory;
import static org.pdfclown.common.build.internal.util_.system.Systems.getBooleanProperty;
import static org.pdfclown.common.build.system.LogManager.MARKER__VERBOSE;

import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Stream;
import org.apache.commons.lang3.function.Failable;
import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.pdfclown.common.build.internal.util_.ParamMessage;
import org.pdfclown.common.build.util.system.Builds;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Support for assertions based on automatically managed state.
 * <p>
 * The expected state (typically persisted as resource file) is automatically managed to ensure easy
 * and robust test maintenance, providing testers with CLI hints to fix unexpected output and update
 * the corresponding resources.
 * </p>
 * <p>
 * In case of error, full assertion reports are written to a dedicated log file
 * ({@code target/test-logs/pdfclown/assert.log}).
 * </p>
 *
 * @author Stefano Chizzolini
 */
public abstract class Asserter {
  /**
   * {@link Asserter} configuration.
   *
   * @author Stefano Chizzolini
   */
  public static class Config implements Cloneable {
    final org.pdfclown.common.build.test.assertion.Test test;

    public Config(org.pdfclown.common.build.test.assertion.Test test) {
      this.test = requireNonNull(test, "`test`");
    }

    @Override
    public Config clone() {
      try {
        return (Config) super.clone();
      } catch (CloneNotSupportedException ex) {
        throw runtime(ex);
      }
    }

    public TestEnvironment getEnv() {
      return test.getEnv();
    }

    public org.pdfclown.common.build.test.assertion.Test getTest() {
      return test;
    }
  }

  /**
   * Error message builder.
   *
   * @author Stefano Chizzolini
   */
  public static class ErrorMessageBuilder {
    private final StringBuilder base = new StringBuilder();

    /**
     * Appends the {@linkplain Object#toString() string representation} of an object to the current
     * error entry.
     */
    public ErrorMessageBuilder append(Object obj) {
      base.append(obj);
      return this;
    }

    /**
     * Appends text to the current error entry.
     */
    public ErrorMessageBuilder append(String text) {
      base.append(text);
      return this;
    }

    /**
     * Begins a new error entry.
     */
    public ErrorMessageBuilder error(String text) {
      if (base.length() > 0) {
        base.append("\n");
      }
      return append(text);
    }

    /**
     * Whether this message is empty.
     */
    public boolean isEmpty() {
      return base.length() == 0;
    }

    /**
     * Begins a new page-related error entry.
     */
    public ErrorMessageBuilder pageError(int pageIndex) {
      return error("Page ").append(pageIndex).append(": ");
    }

    @Override
    public String toString() {
      return base.toString();
    }
  }

  private static final Logger log = LoggerFactory.getLogger(Asserter.class);

  /**
   * CLI parameter specifying whether {@linkplain Asserter assertion} resource building is enabled
   * for executed tests.
   * <p>
   * <b>Assertion resources</b> represent the expected state against which the corresponding actual
   * state generated by the tested project code is validated. If a resource is missing or its
   * validation is false negative because the tested project code innovated the expected state,
   * {@linkplain Asserter asserters} can regenerate it through this CLI parameter.
   * </p>
   * <p>
   * The value of this CLI parameter is a boolean which can be omitted (default: {@code true}).
   * </p>
   *
   * @apiNote Common usage examples (Maven build system):
   *          <ul>
   *          <li>to regenerate all the mismatching resources, no matter the tests they belong to:
   *          <pre class="lang-shell"><code>
   * mvn verify ... -Dassert.files.update</code></pre></li>
   *          <li>to regenerate the mismatching resources belonging to specific test classes (for
   *          example, "MyObjectIT"): <pre class="lang-shell"><code>
   * mvn verify ... -Dassert.files.update -Dtest=MyObjectIT</code></pre></li>
   *          <li>to regenerate the mismatching resources belonging to specific test cases (for
   *          example, "MyObjectIT.myTest"): <pre class="lang-shell"><code>
   * mvn verify ... -Dassert.files.update -Dtest=MyObjectIT#myTest</code></pre></li>
   *          <li>to regenerate the mismatching resources belonging to multiple test classes (for
   *          example, MyObjectIT and MyOtherObjectIT), they can be specified as a comma-separated
   *          list: <pre class="lang-shell"><code>
   * mvn verify ... -Dassert.files.update -Dtest=MyObjectIT,MyOtherObjectIT</code></pre></li>
   *          </ul>
   *          <p>
   *          NOTE: {@code test} CLI parameter is typically mapped by Maven plugins (such as
   *          <a href="https://maven.apache.org/surefire/maven-failsafe-plugin/">Failsafe</a>) to
   *          the corresponding JUnit system property which allows fine-grained test selection (see
   *          the relevant documentation); if your build system doesn't support it, adjust your
   *          commands accordingly. Furthermore, if the names of your test cases are overridden
   *          (that is, their names are different from the corresponding test methods), it's up to
   *          you to use their actual names, as they are internally resolved by JUnit.
   *          </p>
   */
  public static final String PARAM_NAME__UPDATE = "assert.files.update";
  static {
    log.info("`{}` CLI parameter: {}", PARAM_NAME__UPDATE,
        getBooleanProperty(PARAM_NAME__UPDATE));
  }

  /**
   * Evaluates the assertion result and throws an assertion error in case of failure.
   * <p>
   * This method is expected to be invoked at the end of the assertion, after all the detected
   * errors were combined in the message:
   * </p>
   * <ul>
   * <li>if {@code message} is empty, the assertion succeeded: this method quietly returns</li>
   * <li>if {@code message} is not empty, the assertion failed: this method enters the full content
   * of {@code message} into the assertion log, then throws its shortened version as
   * {@link AssertionError}</li>
   * </ul>
   *
   * @param message
   *          Assertion error message (if empty, no error is thrown).
   * @param expectedFile
   *          Expected test result (resource file).
   * @param actualFile
   *          Actual test result (output file).
   * @throws AssertionError
   *           If {@code message} is not empty.
   */
  protected void evalAssertionError(@Nullable String message, Path expectedFile,
      @Nullable Path actualFile) throws AssertionError {
    if (isBlank(message))
      return;

    var testAnnotationTypes = Set.of(Test.class, ParameterizedTest.class);
    String testName = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)
        .walk($frames -> $frames
            .skip(2)
            .<Optional<Method>>map($ -> {
              try {
                return Optional.of($.getDeclaringClass().getDeclaredMethod($.getMethodName(),
                    $.getMethodType().parameterArray()));
              } catch (NoSuchMethodException e) {
                return Optional.empty();
              }
            })
            .filter($ -> $
                .map($$ -> Stream.of($$.getDeclaredAnnotations())
                    .anyMatch($$$ -> testAnnotationTypes.contains($$$.annotationType())))
                .orElse(false))
            .findFirst()
            .map($ -> $
                .map($$ -> $$.getDeclaringClass().getSimpleName() + "#" + $$.getName())
                .orElseThrow())
            .orElse(EMPTY));
    if (testName.isEmpty())
      throw runtime("""
          Failed test method NOT FOUND on call stack (should be marked with any of these \
          annotations: {})""", testAnnotationTypes.stream().map(Class::getName).collect(toList()));

    message = """
        Test %s FAILED:
        %s""".formatted(textLiteral(testName), message);
    String projectArtifactId = Builds.projectArtifactId(expectedFile);
    String hint = ParamMessage.format(
        """

            Compared files:
             * EXPECTED: {}
             * ACTUAL: {}
            To retry, enter this CLI parameter into your command:
              mvn verify -pl {} -Dtest={}
            To confirm the actual changes as expected, enter these CLI parameters into your command:
              mvn verify -pl {} -D{} -Dtest={}
            """,
        expectedFile,
        requireNonNullElse(actualFile, "N/A"),
        projectArtifactId, textLiteral(testName),
        projectArtifactId, PARAM_NAME__UPDATE, textLiteral(testName));

    // Log (full message).
    getLog().error(MARKER__VERBOSE, "{}" + LF + "{}", message, hint);

    // Exception (shortened message).
    throw new AssertionError(
        """
            %s
            (see pdfclown/assert.log for further information)
            %s""".formatted(abbreviateMultiline(message, 5, 100), hint));
  }

  /**
   * Implementation-specific logger.
   */
  protected abstract Logger getLog();

  /**
   * Gets whether the expected resources can be overwritten in case of mismatch with their actual
   * counterparts.
   */
  protected boolean isUpdatable() {
    return getBooleanProperty(PARAM_NAME__UPDATE);
  }

  /**
   * Writes the expected directory resource on both source and target sides.
   *
   * @param resourceName
   *          Resource to write.
   * @param writer
   *          Resource generator.
   * @param config
   *          Assertion configuration.
   */
  protected void writeExpectedDirectory(String resourceName, Consumer<Path> writer, Config config)
      throws IOException {
    // Source directory.
    Path sourceDir = config.getEnv().resourceSrcPath(resourceName);
    try {
      resetDirectory(sourceDir);
      writer.accept(sourceDir);
    } catch (Exception ex) {
      throw failedIO("Expected resource build FAILED: {}", sourceDir, ex);
    }
    getLog().info("Expected directory resource BUILT at {}", textLiteral(sourceDir));

    // Target file.
    Path targetDir = config.getEnv().resourcePath(resourceName);
    try {
      resetDirectory(targetDir);
      copyDirectory(sourceDir, targetDir);
    } catch (Exception ex) {
      throw failedIO("""
          Expected resource copy to target FAILED (re-running tests should fix it): {}""",
          targetDir, ex);
    }
    getLog().info("Expected directory resource COPIED to target at {}", textLiteral(targetDir));
  }

  /**
   * Writes the expected directory resource on both source and target sides.
   *
   * @param resourceName
   *          Resource to write.
   * @param actualDir
   *          Actual directory to overwrite the expected resource.
   * @param config
   *          Assertion configuration.
   */
  protected void writeExpectedDirectory(String resourceName, Path actualDir, Config config)
      throws IOException {
    writeExpectedDirectory(resourceName, Failable.asConsumer($ -> copyDirectory(actualDir, $)),
        config);
  }

  /**
   * Writes the expected resource on both source and target sides.
   *
   * @param resourceName
   *          Resource to write.
   * @param writer
   *          Resource generator.
   * @param config
   *          Assertion configuration.
   */
  protected void writeExpectedFile(String resourceName, Consumer<Path> writer, Config config)
      throws IOException {
    // Source file.
    Path sourceFile = config.getEnv().resourceSrcPath(resourceName);
    try {
      Files.createDirectories(sourceFile.getParent());
      writer.accept(sourceFile);
    } catch (Exception ex) {
      throw failedIO("Expected resource build FAILED: {}", sourceFile, ex);
    }
    getLog().info("Expected resource BUILT at {}", textLiteral(sourceFile));

    // Target file.
    Path targetFile = config.getEnv().resourcePath(resourceName);
    try {
      Files.createDirectories(targetFile.getParent());
      Files.copy(sourceFile, targetFile, REPLACE_EXISTING);
    } catch (Exception ex) {
      throw failedIO("""
          Expected resource copy to target FAILED (re-running tests should fix it): {}""",
          targetFile, ex);
    }
    getLog().info("Expected resource COPIED to target at {}", textLiteral(targetFile));
  }

  /**
   * Writes the expected resource on both source and target sides.
   *
   * @param resourceName
   *          Resource to write.
   * @param actualFile
   *          Actual file to overwrite the expected resource.
   * @param config
   *          Assertion configuration.
   */
  protected void writeExpectedFile(String resourceName, Path actualFile, Config config)
      throws IOException {
    writeExpectedFile(resourceName, Failable.asConsumer(
        $ -> Files.copy(actualFile, $, REPLACE_EXISTING)), config);
  }
}
